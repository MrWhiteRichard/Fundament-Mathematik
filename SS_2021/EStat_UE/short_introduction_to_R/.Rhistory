m  # Print the map
rm(list=ls())
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lat=50.0997, lng=8.67768, popup="The birthplace of R")
m  # Print the map
rm(list=ls())
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lat=50.0997, lng=8.67768, popup="home")
m  # Print the map
rm(list=ls())
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lat=50.0997, lng=8.67768, popup="lori")
m  # Print the map
rm(list=ls())
rm(list=ls())
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lat=50.0997, lng=8.67768, popup="lori")
m  # Print the map
dev.off()
rm(list=ls())
library(leaflet)
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lat=50.0997, lng=8.67768, popup="lori")
m  # Print the map
m = leaflet() %>% addTiles()
df = data.frame(
lat = rnorm(100),
lng = rnorm(100),
size = runif(100, 5, 20),
color = sample(colors(), 100)
)
m = leaflet(df) %>% addTiles()
m %>% addCircleMarkers(radius = ~size, color = ~color, fill = FALSE)
m %>% addCircleMarkers(radius = runif(100, 4, 10), color = c('red'))
m = leaflet() %>% addTiles()
df = data.frame(
lat = rnorm(100),
lng = rnorm(100),
size = runif(100, 5, 20),
color = sample(colors(), 100)
)
m = leaflet(df) %>% addTiles()
m %>% addCircleMarkers(radius = ~size, color = ~color, fill = FALSE)
m %>% addCircleMarkers(radius = runif(100, 4, 10), color = c('red'))
df
m = leaflet() %>% addTiles()
m = leaflet(df) %>% addTiles()
m %>% addCircleMarkers(radius = ~size, color = ~color, fill = FALSE)
m %>% addCircleMarkers(radius = runif(100, 4, 10), color = c('red'))
rm(list=ls())
1 + 1
1:20
1:500
help.start()
?sort            # But you need to know the commands.
a <- 1
rm(list=ls())
gewd()
getwd()
setwd("~/Desktop/short_introduction_to_R")
getwd() # = get working directory
dev.print(device=pdf,file="histogram.pdf") # saves the histogram
hist(rnorm(100)) # creates a histogram
dev.print(device=pdf,file="histogram.pdf") # saves the histogram
5 == 4        # "==" equals, logical values are either "TRUE" or "FALSE"
5 == 4        # "==" equals, logical values are either "TRUE" or "FALSE"
5 == 4        # "==" equals, logical values are either "TRUE" or "FALSE"
# 3 + 5       # comments via #-sign, not executed in console
5 == 4        # "==" equals, logical values are either "TRUE" or "FALSE"
5 >= 4        # ">=" larger or equals, analogously: ">", "<", "<="
is.numeric(pi)
pi
is.character("hello")
c(1,2,4)
c("eins", "zwei", "drei")
c("eins", 2, TRUE)          # Attention: Transformation of the entries to the same type
vek <- c(1,2,-3,4,2)        # "<-" is the assignment arrow
vek                         # accesses the vector
Vek                         # case sensitivity
1:10                        # 1,2,...,10
1:10                        # 1,2,...,10
5:-4                        # 5,4,...,-4
seq(1,10,0.32)              # syntax: seq(from, to, increment,...)
seq(10,1,-1)                # increment is negative
rep(3.4,5)                  # syntax: rep(object, quantity,...)
2 * c(1,2,3)              # Scalar multiplication by components
c(1,3,5) + c(5,3,1)       # Addition by components
c(1,2,3,4) +  0:1      		# = c(1,2,3,4) + c(0,1,0,1)
matrix(1:12,3,4)
1:12
matrix(1:12,3,4)
matrix(vek,2,2)                   # by default the matrix is filled by columns.
matrix(vek,2,2,byrow=TRUE)        # filling by row with the entry "byrow=TRUE"
mat <- diag(5)							      # identity matrix of dimension 5
mat
vek <- c(2:-2,rep(3,4))
vek
vek[4]           # grips the the fourth element.
vek[3:5]         # elements 3,4 und 5. The output is also a vector!!!
vek[-c(2,5,8)]   # "-" means "without". All elements without the second,
vek[vek < 2 & vek >= 0]   # All elements that are smaller < 2 and >= 0.
vek > 2 | vek <= 0
vek[vek > 2 | vek <= 0]   # All elements that are either > 2 or <= 0.
vek > 2 | vek <= 0
vek
vek > 2 | vek <= 0
vek[!(vek < 2)] == vek[vek >= 2]  # All elements that are not <2, are >=2
mat <- matrix(1:20,4,5,byrow=TRUE)
mat
mat[2,4]              # Entry of row 2 and column 4.
mat[c(2,4),c(2,3,5)]  # Submatrix, of rows 2 and 4 and columns 2, 3 and 5
mat[c(2,3),]          # Submatrix of 2nd and 3rd row with all columns.
mat[-2,c(3,4)]        # Submatrix of all but the 2nd row and column 3 and 4
mat[mat > 10 & mat < 18] # output as vector!
is.matrix(mat)
is.vector(mat[mat > 10 & mat < 18])
sqrt(c(2,4))              # square root
abs(-5)                   # absolute value
exp(1:10)                 # exponential function
log(seq(1,2,0.1))         # natural logarithm, general: log(value,basis)
vek <- c(seq(3,10,0.7),10:3)
vek
length(vek)               # length of the vector
min(vek)                  # least component, analog "max()"
sum(vek)                  # sum of components
sort(vek)                 # puts the elements in increasing order.
sort(vek, decreasing=TRUE) # order decreasing
mean(vek)                 # mean value of the components
var(vek)                  # (empirical) variance of the components
sd(vek)                   # (empirical) standard deviation of the components
sample(1:49, 6)           # The weekly lottery results. Uniformely choose
sample(c(0,1), 10, replace=TRUE, prob=c(0.2,0.8))
sample(c(0,1), 10, replace=TRUE, prob=c(0.2,0.8))
bell <- rnorm(1000,1,1)         # sample of 1000 N(1,1) random variables.
hist(bell)                      # Creates a histogram. Syntax: hist(vector,...)
?hist
hist(bell,breaks=seq(-3,5,0.5)) # "breaks" sets the breakpoints between the
?hist
rm(list=ls())
dev.off()
2 + 2
2 + 2
a <- 2
a
hist(rnorm(1000))
help.start()
?sort            # But you need to know the commands.
dev.off()
rm(list=ls())
2 + 2
a <- 2
a
hist(norm(1000))
hist(rnorm(1000))
help.start()
?sort            # But you need to know the commands.
setwd("~/Desktop/short_introduction_to_R")
getwd() # = get working directory
hist(rnorm(100)) # creates a histogram
dev.print(device=pdf,file="histogram.pdf") # saves the histogram
3 +       5   # R ignores spacing, 5+5 equals 5   +     5
2 ^ 3
4 / 7         # Division by "/" (not ":")
4 * 2 + 3     # point before line
4 * (2 + 3)   # R accounts for brackets
3.3 * 2       # Attention, the decimal marker is a point (not comma)
3 / 0         # that's the way it is ;-)...
Inf - 3
Inf - Inf     # NaN = not a number (undefined value)
# 3 + 5       # comments via #-sign, not executed in console
5 == 4        # "==" equals, logical values are either "TRUE" or "FALSE"
5 >= 4        # ">=" larger or equals, analogously: ">", "<", "<="
5 != 4        # "!=" not equals
pi
is.numeric(pi)
is.character("hello")
c(1,2,4)
c("eins", "zwei", "drei")
c("eins", 2, TRUE)          # Attention: Transformation of the entries to the same type
vek <- c(1,2,-3,4,2)        # "<-" is the assignment arrow
vek                         # accesses the vector
Vek                         # case sensitivity
1:10                        # 1,2,...,10
5:-4                        # 5,4,...,-4
seq(1,10,0.32)              # syntax: seq(from, to, increment,...)
rep(3.4,5)                  # syntax: rep(object, quantity,...)
2 * c(1,2,3)              # Scalar multiplication by components
c(1,3,5) + c(5,3,1)       # Addition by components
c(1,2,3,4) +  0:1      		# = c(1,2,3,4) + c(0,1,0,1)
c(1,4,6) < 3              # Logical comparisons refer to all components.
matrix(1:12,3,4)
vek <- c(TRUE,TRUE,FALSE,FALSE)
matrix(vek,2,2)                   # by default the matrix is filled by columns.
matrix(vek,2,2,byrow=TRUE)        # filling by row with the entry "byrow=TRUE"
mat <- diag(5)							      # identity matrix of dimension 5
mat
vek <- c(2:-2,rep(3,4))
vek
vek[4]           # grips the the fourth element.
vek[3:5]         # elements 3,4 und 5. The output is also a vector!!!
vek[-c(2,5,8)]   # "-" means "without". All elements without the second,
vek[vek < 2 & vek >= 0]   # All elements that are smaller < 2 and >= 0.
vek
vek < 2 & vek >= 0
vek[vek < 2 & vek >= 0]   # All elements that are smaller < 2 and >= 0.
vek[vek > 2 | vek <= 0]   # All elements that are either > 2 or <= 0.
vek[!(vek < 2)] == vek[vek >= 2]  # All elements that are not <2, are >=2
vek[!(vek < 2)]
vek[vek >= 2]
vek[!(vek < 2)] == vek[vek >= 2]  # All elements that are not <2, are >=2
mat <- matrix(1:20,4,5,byrow=TRUE)
mat
mat[2,4]              # Entry of row 2 and column 4.
mat[c(2,4),c(2,3,5)]  # Submatrix, of rows 2 and 4 and columns 2, 3 and 5
mat[-2,c(3,4)]        # Submatrix of all but the 2nd row and column 3 and 4
mat[mat > 10 & mat < 18] # output as vector!
is.matrix(mat)
is.vector(mat[mat > 10 & mat < 18])
sqrt(c(2,4))              # square root
abs(-5)                   # absolute value
exp(1:10)                 # exponential function
log(seq(1,2,0.1))         # natural logarithm, general: log(value,basis)
log(seq(1,2,0.1),basis=2)         # natural logarithm, general: log(value,basis)
log(seq(1,2,0.1),base =2)         # natural logarithm, general: log(value,basis)
vek <- c(seq(3,10,0.7),10:3)
vek
length(vek)               # length of the vector
min(vek)                  # least component, analog "max()"
sum(vek)                  # sum of components
sort(vek)                 # puts the elements in increasing order.
sort(vek, decreasing=TRUE) # order decreasing
mean(vek)                 # mean value of the components
var(vek)                  # (empirical) variance of the components
sd(vek)                   # (empirical) standard deviation of the components
sample(1:49, 6)           # The weekly lottery results. Uniformely choose
sample(1:49, 6)           # The weekly lottery results. Uniformely choose
sample(1:49, 6)           # The weekly lottery results. Uniformely choose
sample(c(0,1), 10, replace=TRUE, prob=c(0.2,0.8))
sample(c(0,1), 10, replace=TRUE, prob=c(0.2,0.8))
sample(c(0,1), 10, replace=TRUE, prob=c(0.2,0.8))
sample(c(0,1), 10, replace=TRUE, prob=c(0.2,0.8))
# iid Sample
rnorm(20,2,3)  # generates a sample of 20 independent normally distributed radom
# Density
dnorm(4,2,3)   #value of the density at position 4, of the N(2,3) distribution
# CDF (cumulative distribution function):
pnorm(4,2,3)   	# Value of the cdf of N(2,3) distribution at position 4
# Quantile function:
qnorm(0.5,2,3) # Value of the qunatile function of the N(2,3) distr. at probability p = 0.5
rnorm(10,1:10,seq(1,0.1,-0.1))
dnorm(1:20,1,1)
bell <- rnorm(1000,1,1)         # sample of 1000 N(1,1) random variables.
bell
hist(bell)                      # Creates a histogram. Syntax: hist(vector,...)
?hist
hist(bell,breaks=seq(-3,5,0.5)) # "breaks" sets the breakpoints between the
hist(bell,breaks=seq(-3,5,0.5)) # "breaks" sets the breakpoints between the
bell <- rnorm(1000,1,1)         # sample of 1000 N(1,1) random variables.
hist(bell)                      # Creates a histogram. Syntax: hist(vector,...)
?hist
hist(bell,breaks=seq(-3,5,0.5)) # "breaks" sets the breakpoints between the
hist(bell)                      # Creates a histogram. Syntax: hist(vector,...)
bell <- rnorm(1000,1,1)         # sample of 1000 N(1,1) random variables.
bell
hist(bell)                      # Creates a histogram. Syntax: hist(vector,...)
?hist
hist(bell,breaks=seq(-3,5,0.5)) # "breaks" sets the breakpoints between the
hist(bell,breaks=seq(-3,5,0.5),
col="green",
main="Is this bell shaped?",
col.main="blue",
cex.main=2,
xlab="Value of the random variable",
ylab="This is the frequency in the cell",
cex.lab=0.8,
col.lab="red",
cex.axis=2,
col.axis="purple",
xlim=c(-3,10),
ylim=c(0,300)
)
hist(bell)
par(cex.axis=2) 		# globally doubles the size of the labels.
hist(bell)			    # sizes of the labels in the next graphic appear doubled.
hist(rpois(200,5))	# -> labels still doubled.
#-> close graphical window -> parameters set to default.
dev.off()
hist(bell) 			# -> labels back to normal.
?par
plot(c(1,2),c(5,0))   # Syntax: plot(vector of x-coordinates, vector of y-coordinates,...),
plot(c(1,2),c(5,0),type="l")	# "types" are for example.
plot(c(1,2),c(5,0),type="b")	# "types" are for example.
x <- seq(0,2,0.01)
y <- exp(x)
plot(x,y, type="l", main="exp-function", col="red")
data <- rnorm(1000)
hist(data,prob=TRUE,main="sample of 1000 standard normal distributed rv",xlab="values",ylab="density")
x <- seq(-10,10,0.01)  	# sequence of  x-values
x <- seq(-10,10,0.01)  	# sequence of  x-values
y <- dnorm(x) 			    # creates the values of the density.
lines(x,y,col="red")    # Syntax: lines(vector of x-values, vector of y-values,...)
text(-2,0.3,"green arrow",col="blue",pos=2)
arrows(-2,0.32,-1,0.35,col="green", lwd=2)
dev.print(dev=pdf, file="histogram.pdf")
mat <- matrix(rep(4,6),2,3)
mat
save(mat, file="matrix_mat.RData")
mat
rm(mat)				# Remove object mat from the working space
mat
load("matrix_mat.RData")
mat
plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),main="HAHAHA",xlab=":-)",ylab="(-:")
for(s in 1:30) 	# index s runs from 1 to 30 (Idea: create smiley 1,2,...,30)
{
x  <- runif(1) 	# uniformly choose an x-value on [0,1]
y  <- runif(1)	# uniformly choose an y-value on [0,1]
co <- sample(c("red","green"),1) 		# choose a color, red or green
points(x,y,cex=2.7,col=co,pch=19) 	# plot the smiley (head)
text(x,y,":-)")							# plot the face
text(x,y,s,pos=3)						# assign its number s
}
plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),main="Random generation of smilies on the unit square",xlab=":-)",ylab="(-:")
green <- rep(NA,30) # placeholder
green
for(s in 1:30)
{
x  <- runif(1)
y  <- runif(1)
co <- sample(c("red","green"),1)
points(x,y,cex=2.7,col=co,pch=19)
text(x,y,":-)")
text(x,y,s,pos=3)
green[s] <- co == "green"		# TRUE iff co is green
}
green
sum(green)		# number of green smilies. TRUE <-> 1, FALSE <-> 0
legend(x="topleft",legend=c(sum(green),30-sum(green)),pch=rep(19,2),col=c("green","red"),title="No. Smilies")
?legend
x <- 10
if(x>5){print("larger than 5")}
x <- 3
if(x>5){print("larger than 5")}
if(x>5){print("larger than 5")} else{print("smaller than 6")}
s <- 0
repeat
{
s <- s+1
print(s)
if(s>10) break
}
s
w <- 0
while(w<11)
{
w <- w+1
print(w)
}
w
4^3
cube <- function(x){x * x * x}
cube(4)
cube(1:10)
smilies <- function(n=10, second_color="red")
{
plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),main="Random generation of smilies on the unit square",xlab=":-)",ylab="(-:")
green <- rep(NA,n) # depends on input n
for(s in 1:n) # depends on input n
{
x  <- runif(1)
y  <- runif(1)
co <- sample(c("green",second_color),1)	# depends on input second_color
points(x,y,cex=2.7,col=co,pch=19)
text(x,y,":-)")
text(x,y,s,pos=3)
green[s] <- co == "green"
}
sum(green)
}
smilies() # default n=10 and second color_color="red"
smilies(n=20, second_color="blue")
dat <- read.table(file = "dataset.txt")
dat
dat <- read.table(file = "dataset.txt", header=TRUE)
year
attach(dat) # Gives access to variables
year
detach(dat) # Detaches variables
year
data.class(dat) # The class data.frame can handle columns of different data.type
is.logical(logical)
is.numeric(year)
is.logical(logical)
is.numeric(year)
data.class(dat) # The class data.frame can handle columns of different data.type
is.logical(logical)
dat <- read.table(file = "dataset.txt", header=TRUE)
dat
year
attach(dat) # Gives access to variables
year
detach(dat) # Detaches variables
year
data.class(dat) # The class data.frame can handle columns of different data.type
is.logical(logical)
is.numeric(year)
logical
data.class(dat) # The class data.frame can handle columns of different data.type
year
attach(dat) # Gives access to variables
is.logical(logical)
is.numeric(year)
plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),main="HAHAHA",xlab=":-)",ylab="(-:")
for(s in 1:30) 	# index s runs from 1 to 30 (Idea: create smiley 1,2,...,30)
{
x  <- runif(1) 	# uniformly choose an x-value on [0,1]
y  <- runif(1)	# uniformly choose an y-value on [0,1]
co <- sample(c("red","green"),1) 		# choose a color, red or green
points(x,y,cex=2.7,col=co,pch=19) 	# plot the smiley (head)
text(x,y,":-)")							# plot the face
text(x,y,s,pos=3)						# assign its number s
}
plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),main="Random generation of smilies on the unit square",xlab=":-)",ylab="(-:")
green <- rep(NA,30) # placeholder
green
for(s in 1:30)
{
x  <- runif(1)
y  <- runif(1)
co <- sample(c("red","green"),1)
points(x,y,cex=2.7,col=co,pch=19)
text(x,y,":-)")
text(x,y,s,pos=3)
green[s] <- co == "green"		# TRUE iff co is green
}
green
sum(green)		# number of green smilies. TRUE <-> 1, FALSE <-> 0
legend(x="topleft",legend=c(sum(green),30-sum(green)),pch=rep(19,2),col=c("green","red"),title="No. Smilies")
?legend
x <- 10
x <- 10
if(x>5){print("larger than 5")}
x <- 3
if(x>5){print("larger than 5")}
if(x>5){print("larger than 5")} else{print("smaller than 6")}
s <- 0
s <- 0
repeat
{
s <- s+1
print(s)
if(s>10) break
}
s
w <- 0
while(w<11)
{
w <- w+1
print(w)
}
w
4^3
cube <- function(x){x * x * x}
cube(4)
cube(1:10)
smilies <- function(n=10, second_color="red")
{
plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),main="Random generation of smilies on the unit square",xlab=":-)",ylab="(-:")
green <- rep(NA,n) # depends on input n
for(s in 1:n) # depends on input n
{
x  <- runif(1)
y  <- runif(1)
co <- sample(c("green",second_color),1)	# depends on input second_color
points(x,y,cex=2.7,col=co,pch=19)
text(x,y,":-)")
text(x,y,s,pos=3)
green[s] <- co == "green"
}
sum(green)
}
smilies() # default n=10 and second color_color="red"
smilies(n=20, second_color="blue")
dat <- read.table(file = "dataset.txt")
dat
dat <- read.table(file = "dataset.txt", header=TRUE)
dat
year
detach(dat) # Detaches variables
detach(dat) # Detaches variables
dat <- read.table(file = "dataset.txt", header=TRUE)
dat
year
attach(dat) # Gives access to variables
year
detach(dat) # Detaches variables
year
data.class(dat) # The class data.frame can handle columns of different data.type
attach(dat)
is.logical(logical)
is.numeric(year)
dat2 <- read.csv(file = "dataset.csv", header=TRUE)
dat2
