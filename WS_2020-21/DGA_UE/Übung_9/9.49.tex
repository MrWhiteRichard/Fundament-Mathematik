% -------------------------------------------------------------------------------- %

\begin{exercise}

\phantom{}

\begin{enumerate}[label = \alph*)]
  \item Erzeugt die folgende Modifikation des Fisher-Yates-Algorithmus ebenfalls
  eine zufällige Permutation von $A$? Weshalb oder weshalb nicht?

  \begin{algorithmic}
      \State \textsc{Permute-With-All}($A[1,\dots,n]$)
      \State $n = A.$length
      \For{$i = 1 ~\text{to}~ n$}
          \State Vertausche $A[i]$ mit $A[\textsc{Random}(1,n)]$
      \EndFor
  \end{algorithmic}

  \item Eine weitere Abwandlung des Fisher-Yates-Algorithmus: Diesmal wird das
  Element $A[i]$ in jedem Schritt mit einem zufälligen Element aus dem Teilfeld
  $A[i+1,\dots,n]$ vertauscht, also

  \begin{algorithmic}
    \State \textsc{Permute-Without-Identity}($A[1,\dots,n]$)
    \State $n = A.$length
    \For{$i = 1 \text{ to } n$}
      \State Vertausche $A[i]$ mit $A[\textsc{Random}(i+1,n)]$
    \EndFor
  \end{algorithmic}

  Man könnte zunächst meinen, dass dieser Algorithmus alle von der Identität
  verschiedenen Permutationen zufällig erzeugt. Weisen Sie nach, dass dies aber
  nicht der Fall ist. Überlegen Sie sich, welche Klasse von Permutationen von
  diesem Algorithmus tatsächlich zufällig erzeugt werden.
\end{enumerate}

\end{exercise}

% -------------------------------------------------------------------------------- %


\begin{solution}

\phantom{}

\begin{enumerate}[label = \alph*)]
  \item Der Algorithmus kann im Allgemeinen keine zufällige Permutation von $A$ liefern.
  Das sieht man daran, dass in jedem Schleifendurchlauf $n$ gleich wahrscheinliche
  Resultate auftreten. Nach dem $n$-ten Schleifendurchlauf erhalten wir somit
  genau $n^n$ gleich wahrscheinliche (nicht notwendigerweise verschiedene) Permutationen von $A$. Bereits für $n = 3$
  kann dabei nicht jede Permutation gleich häufig auftreten da $\frac{3^3}{3!} = \frac{27}{6}$
  keine ganze Zahl ist.
  \item Der Algorithmus \textsc{Permute-Without-Identity} kann nur Permutationen
  erzeugen, in denen kein Element von $A$ an der selben Stelle wie am Anfang stehen bleibt. \\
  Bezeichne mit $A_i$ das Datenfeld nach dem $i$-ten Durchlauf der Schleife und
  gelte weiters für das Anfangsdatenfeld $A_0$ o.B.d.A. $A_0[i] = i$ für $i = 1,\dots,n$. \\
  Wir zeigen also mit Induktion nach $i = 1,\dots,n: \forall j \leq i: A_i[j] \neq j$. \\
  Der Induktionsanfang $i = 1$ ist klar: $A_1[1] = A[\textsc{Random}(2,n)] \neq 1$. \\
  Im $(i+1)$-ten Schleifendurchlauf werden die ersten $i$ Elemente des Datenfelds $A_i$
  nicht mehr angerührt, also gilt laut Induktionsvoraussetzung $A_{i+1}[j] \neq j$
  für $j = 1,\dots,n$. Weiters gilt $A_{i+1}[i+1] = A[\textsc{Random}(i+2,n)] \neq i +1$. \\
  Jetzt könnte man sich noch überlegen, ob alle Permutationen, die obige
  Bedingung erfüllen, tatsächlich durch den Algorithmus erreicht werden können. \\
  Dem ist aber nicht so, wie man an folgendem Beispiel sieht:
  \begin{align*}
    (1,2,3,4) \rightsquigarrow (4,2,3,1) \rightsquigarrow (4,3,2,1)
    \rightsquigarrow (4,3,1,2)
  \end{align*}
  Also kann die fixpunktfreie Permutation $(4,3,2,1)$ mittels diesem Algorithmus
  nicht erreicht werden.
\end{enumerate}

\end{solution}
