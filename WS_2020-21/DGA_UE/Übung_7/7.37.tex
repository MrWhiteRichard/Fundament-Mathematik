% --------------------------------------------------------------------------------

\begin{exercise}

Geben Sie einen Algorithmus mit Laufzeit $\Landau(|V| + |E|)$ an, dessen Eingabe ein gerichteter azyklischer Graph $G = (V, E)$ und zwei Knoten $s$ und $t$ sind, der die Anzahl der (gerichteten) Wege von $s$ nach $t$ berechnet.
Beispielsweise enthält der Graph aus Aufgabe 50 drei Wege von $b$ nach $i$ nämlich $b - d - e - h - i$, $b - d - f - h - i$ und $b - g - i$.
(Anmerkung: der Algorithmus soll die Pfade bloß zählen, nicht ausgeben) \\

Hinweis:
Topologisches Sortieren

\end{exercise}

% --------------------------------------------------------------------------------

\begin{comment}

\begin{solution}

\phantom{}

\includegraphicsboxed{DGA/DGA - Algorithmus 26 - Linearisieren (Topologisches Sortieren).png}

\blockquote
{
    Wieso wird bei der Aufgabe 37 auf die Aufgabe 50 verwiesen?
    Letztere ist ja auf einem Übungszettel, der noch nicht einmal auf TUWEL steht?!
} \\

Folgender rekursiver Algorithmus verwendet nicht Topologisches Sortieren?!

\begin{algorithm}
    \caption{Anzahl der gerichteten Wege eines gerichteten azyklischen Graphen $G = (V, E)$ von $s$ nach $t$}
    \begin{algorithmic}[1]
        \Procedure{AnzahlGerichteteWege}{$V, E, s, t$}
            \If{$t = s$}
                \State \Return $1$
            \Else
                \State $n := 0$
                \For{$(v, t) \in E$}
                    \State $n := n + \textsc{AnzahlGerichteteWege}(V, E, s, v)$
                \EndFor
                \State \Return $n$
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

So wie der Algorithmus dasteht, besucht die \textbf{for}-Schleife die Kanten $\in E$ höchstens einmal.
Insofern, könnte man meinen, er hat Aufwand $\Landau(|E|) \leq \Landau(|V| + |E|)$.
Ich bin da aber trotzdem skeptisch.
Auf der anderen Seite, wird dasselbe in Algorithmus 26 - Linearisieren (Topologisches Sortieren) gemacht. \\

\textbf{Bitte nicht weglöschen, sondern diskutieren bzw. wenn dann auskommentieren.}

\end{solution}

\end{comment}

% --------------------------------------------------------------------------------

\begin{solution}

\phantom{}

\begin{algorithm}
    \caption{Anzahl der gerichteten Wege eines gerichteten azyklischen Graphen $G = (V, E)$ von $s$ nach $t$}
    \begin{algorithmic}[1]
        \Procedure{AnzahlPfade}{$E, s, t$}
        \State Setze $v.n := +\infty$ für alle $v \in V$
        \State \Return \textsc{AnzahlPfadeRek}($E,s,t$)
        \EndProcedure
    \\
        \Procedure{AnzahlPfadeRek}{$E,s,t$}
            \If{$s.n = +\infty$}
                \If{$s = t$}
                    \State $s.n := 1$
                \Else
                    \State $s.n := 0$
                    \For{$(s,w) \in E$}
                        \State $s.n := s.n\ +$ \textsc{AnzahlPfadeRek}($E,w,t$)
                    \EndFor
                \EndIf
            \EndIf
            \State \Return $v.n$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\end{solution}

% --------------------------------------------------------------------------------

\begin{solution}

Bestimme zuerst mittels Breiten- oder Tiefensuche den Teilgraphen $G^\prime = (V^\prime, E^\prime) \subseteq G = (V, E)$, welcher aus all jenen Knoten besteht, welche von $s$ ausgehend erreicht werden können und $E^\prime$ die Kanten, die übrig bleiben.

\begin{gather*}
    G^\prime = (V^\prime, E^\prime), \\
    V^\prime = \Bbraces{v \in V: \Exists p ~\text{Pfad mit Kanten} \in E: p ~\text{verbindet}~ s ~\text{und}~ v},
    \quad
    E^\prime = E\cap (V^\prime \times V^\prime)
\end{gather*}

Dann können wir folgenden, an das topologische Sortieren angelehnten Algorithmus anwenden.

\phantom{}
	\begin{algorithm}
		\caption{Anzahl der gerichteten Wege eines gerichteten azyklischen Graphen $G = (V, E)$ von $s$ nach $t$}
		\begin{algorithmic}[1]
			\Procedure{AnzahlGerichteteWege}{$V, E, s, t$}
			\State Sei \textit{pfadeZu} ein neues Datenfeld der Länge $|V|$ überall mit $0$ initialisiert
			\State Sei \textit{eingangsgrad} ein neues Datenfeld der Länge $|V|$ überall mit $0$ initialisiert
			\For{alle $(v, w) \in E$}
				\State $\textit{eingangsgrad}[w] := \textit{eingangsgrad}[w] + 1$
			\EndFor
			\State Sei $M$ neue Warteschlange oder Stapel leer initialisiert
			\State $\textsc{Hinzufügen}(M,s)$
			\State $\textit{pfadeZu}[s] := 1$ weil der leere Pfad von $s$ nach $s$ führt
			\While{$M$ nicht leer}
				\State $v := \textsc{Entfernen}(M)$
				\For{alle $(v, w) \in E$}
					\State $\textit{pfadeZu}[w] := \textit{pfadeZu}[w] + \textit{pfadeZu}[v]$ weil wir auch von $s$ nach $v$ und dann, vermöge $(v, w)$, nach $w$ gehen können
					\State $\textit{eingangsgrad}[w] := \textit{eingangsgrad}[w] - 1$, weil wir wollen keinen Pfad doppelt zählen
					\If{$\textit{eingangsgrad}[w] = 0$ d.h. alle Pfade von $s$ nach $w$ wurden gefunden}
						\State $\textsc{Hinfufügen}(M, w)$
					\EndIf
				\EndFor
			\EndWhile
			\State \Return $\textit{pfadeZu}[t]$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
\end{solution}

Die Vorarbeit wird gebraucht, um folgende Situation zu vermeiden.

\includegraphicsunboxed{7.37.png}

Der Algorithmus 2 alleine würde sofort terminieren, weil die Nachbarknoten von $s$ Eingangsgrad $2$ haben und somit keiner mit Eingangsgrad $0 < 1 = 2 - 1$ entsteht.

Breiten- und Tiefensuche haben Aufwand $\Landau(|V| + |E|)$.
Der obere Algorithmus hat ebenfalls Aufwand $\Landau(|V| + |E|)$.
Wenn man diese hintereinander ausführt, hat die Komposition noch immer Aufwand $\Landau(|V| + |E|)$.

% --------------------------------------------------------------------------------

\FloatBarrier
