% --------------------------------------------------------------------------------

\begin{exercise}

\phantom{}

\begin{enumerate}[label = (\alph*)]

    \item Binäre Suche:
    Gegeben sei ein (aufsteigend) sortiertes Datenfeld $A[1, \ldots, n]$ und ein Wert $x$.
    Das sogenannte Suchproblem, also einen Index $j$ mit $x = A[j]$ auszugeben, falls $x$ in $A$ enthalten ist, und einen speziellen Wert $\NIL$ auszugeben, falls $x$ nicht in $A$ vorkommt, kann hier mittels Divide-and-Conquer gelöst werden.
    Man vergleicht $x$ mit dem mittleren Element des Datenfelds und ist nach diesem Vergleichen entweder fündig geworden oder braucht nur noch das halbe Datenfeld mit der gleichen Prozedur zu durchsuchen.
    Schreiben Sie ein Programm in Pseudocode für die binäre Suche.
    Begründen Sie, warum die Laufzeit der binären Suche im schlechtesten Fall $\Landau{\log{n}}$ ist.

    \item Beim Algorithmus Einfügesortieren wird die sequentielle Suche verwendet, um das bereits sortierte Teilfeld $A[1, \ldots, n]$ (rückwärts) zu durchsuchen.
    Kann stattdessen die binäre Suche verwendet werden, um die worst-case-Laufzeit von Insertion Sort auf $\Landau{\log{n}}$ zu verbessern?

\end{enumerate}

\end{exercise}

% --------------------------------------------------------------------------------

\begin{solution}

\phantom{}

\begin{enumerate}[label = (\alph*)]

	\item

	\begin{flalign*}
		1&:  \textbf{Prozedur}~ \textsc{Divide-and-Conquer-Suche} (A, x, j := 0) & \\
		2&:  \quad n := A.\textit{Länge} & \\
		3&:  \quad \textbf{Wenn}~ n \neq 1 & \\
		4&:  \quad \quad k := \floorbraces{\nicefrac{n}{2}} & \\
		5&:  \quad \quad \textbf{Wenn}~ x > A[k] & \\
		6&:  \quad \quad \quad j := j + k & \\
		7&:  \quad \quad \quad B := A[k+1, \dots, n] & \\
		8&:  \quad \quad \quad \textsc{Divide-and-Conquer-Suche} (B, x, j) & \\
		9&:  \quad \quad \textbf{Sonst Wenn}~ x < A[k] & \\
		10&: \quad \quad \quad B := A[1, \dots, k-1] & \\
		11&: \quad \quad \quad \textsc{Divide-and-Conquer-Suche} (B, x, j) & \\
		12&: \quad \quad \textbf{Sonst} & \\
		13&: \quad \quad \quad j := j + k & \\
		14&: \quad \quad \textbf{Ende Wenn} & \\
		15&: \quad \textbf{Sonst Wenn}~ A[1] = x & \\
		16&: \quad \quad j := j + 1 & \\
		17&: \quad \textbf{Sonst} & \\
		18&: \quad \quad j := \NIL & \\
		19&: \quad \textbf{Ende Wenn} & \\
		20&: \textbf{Ende Prozedur}
	\end{flalign*}

	Die Wenn-Bedingung in der $2$-ten Zeile wird maximal $\ceilbraces{\log_2(n)}$ mal überprüft
	und damit wird jede Zeile innerhalb des Wenn-Blocks maximal $\ceilbraces{\log_2(n)}$ mal ausgeführt.
	Alle anderen Zeilen werden maximal einmal ausgeführt.

	\begin{flalign*}
		1&:  \textbf{Prozedur}~ \textsc{Divide-and-Conquer-Suche} (A, x) & \\
		2&:  \quad a := 0 & \\
		3&:  \quad b := A.\textit{Länge} + 1 & \\
		4&:  \quad j := \floorbraces{(b - a) / 2} & \\
		5&:  \quad \textbf{Solange}~ b - a > 1 ~\textbf{und}~ A[a + j] \neq x & \\
		6&:  \quad \quad \textbf{Wenn}~ A[a + j] < x & \\
		7&:  \quad \quad \quad a := a + j + 1 & \\
		8&:  \quad \quad \textbf{Sonst} & \\
		9&:  \quad \quad \quad b := a + j & \\
		10&: \quad \quad \textbf{Ende Wenn} & \\
		11&: \quad \quad j := \floorbraces{(b - a) / 2} & \\
		12&: \quad \textbf{Ende Solange} & \\
		13&: \quad \textbf{Wenn}~ j = 0 & \\
		14&: \quad \quad j := \NIL & \\
		15&: \quad \textbf{Ende Wenn} & \\
		16&: \textbf{Ende Prozedur}
	\end{flalign*}

	Es ist nicht ganz klar, was in der Angabe mit begründen gemeint ist.
	Ein sauberer Beweis oder die Bemerkung, dass die Länge des Datenfeldes sich stets halbiert, die Schleife also sicher nicht öfter als $\ceilbraces{\log_2(n)}$ Mal ausgeführt wird?

	\item \phantom{}
	
	\includegraphicsboxed{Hetzl - Algorithmus 2 - Einfügesortieren.png}
	
	Beim Algorithmus Einfügesortieren wird die äußere Schleife stets $(n - 1)$-Mal durchlaufen.
	Ersetzt man die innere Schleife durch ein ähnliches Verfahren wie die Prozedur Divide-and-Conquer-Suche, so wird im schlechtesten Fall die innere Schleife im $j$-ten Durchlauf der äußeren Schleife $\ceilbraces{\log_2{j}}$-Mal durchlaufen.
	Es ergibt sich so folgender Aufwand.

	\begin{multline*}
		\sum_{j = 2}^{n}
		\ceilbraces{\log_2{j}}
		\geq
		\sum_{j=2}^n
		\log_2{j}
		\geq
		\Int[1][n]{\log_2{x}}{x}
		=
		\frac{1}{\log{2}}
		\Int[1][n]{\log{x}}{x} \\
		=
		\Frac
		{\log{2}}
		{
			(n \log{n} - n)
			-
			(1 \log{1} - 1)
		}
		=
		\Frac
		{\log{2}}
		{n (\log{n} - 1) + 1}
		=
		\Landau{n \log{n}}
		>
		\Landau{\log{n}}
	\end{multline*}

	Die worst-case-Laufzeit von Insertion Sort lässt sich daher nicht einmal durch anwenden der binären Suche auf $\Landau{\log{n}}$ verbessern.

\end{enumerate}

\end{solution}

% --------------------------------------------------------------------------------
