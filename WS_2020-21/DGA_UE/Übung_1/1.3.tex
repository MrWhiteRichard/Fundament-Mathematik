% --------------------------------------------------------------------------------

\begin{exercise}

\phantom{}

\begin{enumerate}[label = (\alph*)]

    \item Binäre Suche:
    Gegeben sei ein (aufsteigend) sortiertes Datenfeld $A[1, \ldots, n]$ und ein Wert $x$.
    Das sogenannte Suchproblem, also einen Index $j$ mit $x = A[j]$ auszugeben, falls $x$ in $A$ enthalten ist, und einen speziellen Wert $\NIL$ auszugeben, falls $x$ nicht in $A$ vorkommt, kann hier mittels Divide-and-Conquer gelöst werden.
    Man vergleicht $x$ mit dem mittleren Element des Datenfelds und ist nach diesem Vergleichen entweder fündig geworden oder braucht nur noch das halbe Datenfeld mit der gleichen Prozedur zu durchsuchen.
    Schreiben Sie ein Programm in Pseudocode für die binäre Suche.
    Begründen Sie, warum die Laufzeit der binären Suche im schlechtesten Fall $\Landau{\log{n}}$ ist.

    \item Beim Algorithmus Einfügesortieren wird die sequentielle Suche verwendet, um das bereits sortierte Teilfeld $A[1, \ldots, n]$ (rückwärts) zu durchsuchen.
    Kann stattdessen die binäre Suche verwendet werden, um die worst-case-Laufzeit von Insertion Sort auf $\Landau{\log{n}}$ zu verbessern?

\end{enumerate}

\end{exercise}

% --------------------------------------------------------------------------------

\begin{solution}
\begin{enumerate}[label = (\alph*)]
\item
\begin{flalign*}
&1: \textbf{Prozedur}~ \textsc{Divide-and-Conquer-Suche} (A,x, j := 0) &\\
&2: \quad n := A.\textit{Länge} &\\
&3: \quad \textbf{Wenn}~ n \neq 1: &\\
&4: \quad \quad k := \lfloor\nicefrac{n}{2}\rfloor &\\
&5: \quad \quad \textbf{Wenn}~ x > A[k]: &\\
&6: \quad \quad \quad j := j + k &\\
&7: \quad \quad \quad B := A[k+1,\dots,n] &\\
&8: \quad \quad \quad \textsc{Divide-and-Conquer-Suche} (B,x,j) &\\
&9: \quad \quad \textbf{Sonst Wenn}~ x < A[k]: &\\
&10: \quad \quad \quad B := A[1,\dots,k-1]&\\
&11: \quad \quad \quad \textsc{Divide-and-Conquer-Suche} (B,x,j) &\\
&12: \quad \quad \textbf{Sonst}: &\\
&13: \quad \quad \quad j := j + k&\\
&14: \quad \quad \textbf{Ende Wenn} &\\
&15: \quad \textbf{Sonst Wenn}~ A[1] = x:&\\
&16: \quad \quad j := j + 1&\\
&17: \quad \textbf{Sonst} &\\
&18: \quad \quad j := NIL&\\
&19: \quad \textbf{Ende Wenn} &\\
&20: \textbf{Ende Prozedur}
\end{flalign*}

Die Wenn-Bedingung in Zeile 2 wird maximal $\lceil\log_2(n)\rceil$ mal überprüft
und damit wird jede Zeile innerhalb des Wenn-Blocks maximal $\lceil\log_2(n)\rceil$ mal ausgeführt.
Alle anderen Zeilen werden maximal einmal ausgeführt.

\item Ja.
\end{enumerate}
\end{solution}

% --------------------------------------------------------------------------------
\begin{solution}
	\begin{flalign*}
	&~1: \textbf{Prozedur}~ \textsc{Divide-and-Conquer-Suche} (A,x) &\\
	&~2: \quad a := 0 &\\
	&~3: \quad e := A.L"ange + 1 &\\
	&~4: \quad j := \lfloor(e - a) / 2\rfloor &\\
	&~5: \quad \textbf{Solange}~ e - a > 1 ~ und ~ A[a + j] \neq x &\\
	&~6: \quad \quad \textbf{Wenn}~ x > A[a + j]&\\
	&~7: \quad \quad \quad a := a + j &\\
	&~8: \quad \quad \textbf{Sonst} &\\
	&~9: \quad \quad \quad e := a + j &\\
	&10: \quad \quad \textbf{Ende Wenn}&\\
	&11: \quad \quad j := \lfloor(e - a) / 2\rfloor &\\
	&12: \quad \textbf{Ende Solange}: &\\
	&13: \quad \textbf{Wenn}~ j = 0&\\
	&14: \quad \quad j := NIL &\\
	&15: \quad \textbf{Ende Wenn}&\\
	&16: \textbf{Ende Prozedur}
	\end{flalign*}
	Hier ist nicht ganz klar was in der Angabe mit begr"unden gemeint ist. Ein sauberer Beweis oder die Bemerkung, dass die Länge des Datenfeldes sich stets halbiert, die Schleife also sicher nicht "ofter als $\lceil\log_2(n)\rceil$ Mal ausgef"uhrt wird. 
	
	Beim Algorithmus Einfügesortieren wird die äußere Schleife stets $n$ Mal durchlaufen, ersetzt man die innere Schleife durch ein ähnliches Verfahren wie die Prozedur Divide-and-Conquer-Suche so wird im schlechtesten Fall die innere Schleife im $j$-ten Durchlauf der äußeren Schleife $\lceil\log_2(j)\rceil$ Mal durchlaufen. Ergibt sich so ein Aufwand von
	\begin{align*}
	\sum_{j = 2}^{n} \lceil\log_2(j)\rceil &\geq \sum_{j = 2}^{n} \log_2(j) \geq \int_1^n \log_2(x) dx = \frac{1}{\log(2)} \int_1^n \log(x) dx \\
	&= \frac{1}{\log(2)}((n\log(n) - n) - (1\log(1) - 1)) = \frac{1}{\log(2)}(n(\log(n) - 1) + 1)
	\end{align*}
\end{solution}