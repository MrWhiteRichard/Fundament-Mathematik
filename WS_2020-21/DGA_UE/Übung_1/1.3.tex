% --------------------------------------------------------------------------------

\begin{exercise}

\phantom{}

\begin{enumerate}[label = (\alph*)]

    \item Binäre Suche:
    Gegeben sei ein (aufsteigend) sortiertes Datenfeld $A[1, \ldots, n]$ und ein Wert $x$.
    Das sogenannte Suchproblem, also einen Index $j$ mit $x = A[j]$ auszugeben, falls $x$ in $A$ enthalten ist, und einen speziellen Wert $\NIL$ auszugeben, falls $x$ nicht in $A$ vorkommt, kann hier mittels Divide-and-Conquer gelöst werden.
    Man vergleicht $x$ mit dem mittleren Element des Datenfelds und ist nach diesem Vergleichen entweder fündig geworden oder braucht nur noch das halbe Datenfeld mit der gleichen Prozedur zu durchsuchen.
    Schreiben Sie ein Programm in Pseudocode für die binäre Suche.
    Begründen Sie, warum die Laufzeit der binären Suche im schlechtesten Fall $\Landau{\log{n}}$ ist.

    \item Beim Algorithmus Einfügesortieren wird die sequentielle Suche verwendet, um das bereits sortierte Teilfeld $A[1, \ldots, n]$ (rückwärts) zu durchsuchen.
    Kann stattdessen die binäre Suche verwendet werden, um die worst-case-Laufzeit von Insertion Sort auf $\Landau{\log{n}}$ zu verbessern?

\end{enumerate}

\end{exercise}

% --------------------------------------------------------------------------------

\begin{solution}

\phantom{}

\begin{enumerate}[label = (\alph*)]

	\item

  \begin{flalign*}
		1&:  \textbf{Prozedur}~ \textsc{Divide-and-Conquer-Suche} (A, x) & \\
		2&:  \quad a := 1 & \\
		3&:  \quad b := A.\textit{Länge} & \\
		4&:  \quad j := \floorbraces{(b - a) / 2} & \\
		5&:  \quad \textbf{Solange}~ b - a > 0 ~\textbf{und}~ A[a + j] \neq x & \\
		6&:  \quad \quad \textbf{Wenn}~ A[a + j] < x & \\
		7&:  \quad \quad \quad a := a + j + 1 & \\
		8&:  \quad \quad \textbf{Sonst} & \\
		9&:  \quad \quad \quad b := a + j - 1& \\
		10&: \quad \quad \textbf{Ende Wenn} & \\
		11&: \quad \quad j := \floorbraces{(b - a) / 2} & \\
		12&: \quad \textbf{Ende Solange} & \\
		13&: \quad \textbf{Wenn}~ j = 0 & \\
		14&: \quad \quad j := \NIL & \\
    15&: \quad \textbf{Sonst} & \\
    16&: \quad \quad j := j + a & \\
		17&: \quad \textbf{Ende Wenn} & \\
		18&: \textbf{Ende Prozedur}
	\end{flalign*}

	In jedem Schritt des Solange-Block wird $(b-a)$ mindestens halbiert (oder die Schleife bricht ab): \\
  Fall 1: $A[a+j] < x$
  \begin{align*}
    b^{\prime} - a^{\prime} = b - a - j - 1 = b - a - \floorbraces{(b - a) / 2} - 1 \leq \frac{b-a}{2}
  \end{align*}
  Fall 2: $A[a+j] > x$
  \begin{align*}
    b^{\prime} - a^{\prime} = a + j - 1 - a = j - 1 \leq \frac{b - a}{2}
  \end{align*}
  Fall 3: $A[a+j] = x$ \\
  Die Solange-Bedingung ist nicht mehr erfüllt und wir haben den letzten Schleifendurchlauf erreicht. \\
  Insgesamt ist nach $\ceilbraces{\log_2(n)}$ in jedem Fall die Solange-Bedingung verletzt und somit
  wird der Solange-Block maximal $\ceilbraces{\log_2(n)}$ oft ausgeführt, was
  uns insgesamt auf einen Aufwand von $\Landau{n}$ führt.

	\begin{flalign*}
		1&:  \textbf{Prozedur}~ \textsc{Divide-and-Conquer-Suche} (A, x) & \\
		2&:  \quad a := 0 & \\
		3&:  \quad b := A.\textit{Länge} + 1 & \\
		4&:  \quad j := \floorbraces{(b - a) / 2} & \\
		5&:  \quad \textbf{Solange}~ b - a > 0 ~\textbf{und}~ A[a + j] \neq x & \\
		6&:  \quad \quad \textbf{Wenn}~ A[a + j] < x & \\
		7&:  \quad \quad \quad a := a + j + 1 & \\
		8&:  \quad \quad \textbf{Sonst} & \\
		9&:  \quad \quad \quad b := a + j & \\
		10&: \quad \quad \textbf{Ende Wenn} & \\
		11&: \quad \quad j := \floorbraces{(b - a) / 2} & \\
		12&: \quad \textbf{Ende Solange} & \\
		13&: \quad \textbf{Wenn}~ j = 0 & \\
		14&: \quad \quad j := \NIL & \\
		15&: \quad \textbf{Ende Wenn} & \\
		16&: \textbf{Ende Prozedur}
	\end{flalign*}
	Es ist nicht ganz klar, was in der Angabe mit begründen gemeint ist.
	Ein sauberer Beweis oder die Bemerkung, dass die Länge des Datenfeldes sich stets halbiert, die Schleife also sicher nicht öfter als $\ceilbraces{\log_2(n)}$ Mal ausgeführt wird?

	\item \phantom{}

	\includegraphicsboxed{Hetzl - Algorithmus 2 - Einfuegesortieren.png}

	Beim Algorithmus Einfügesortieren wird die äußere Schleife stets $(n - 1)$-Mal durchlaufen.
	Ersetzt man die innere Schleife durch ein ähnliches Verfahren wie die Prozedur Divide-and-Conquer-Suche, so wird im schlechtesten Fall die innere Schleife im $j$-ten Durchlauf der äußeren Schleife $\ceilbraces{\log_2{j}}$-Mal durchlaufen.
	Es ergibt sich so folgender Aufwand.

	\begin{multline*}
		\sum_{j = 2}^{n}
		\ceilbraces{\log_2{j}}
		\geq
		\sum_{j=2}^n
		\log_2{j}
		\geq
		\Int[1][n]{\log_2{x}}{x}
		=
		\frac{1}{\log{2}}
		\Int[1][n]{\log{x}}{x} \\
		=
		\Frac
		{\log{2}}
		{
			(n \log{n} - n)
			-
			(1 \log{1} - 1)
		}
		=
		\Frac
		{\log{2}}
		{n (\log{n} - 1) + 1}
		=
		\Landau{n \log{n}}
		>
		\Landau{\log{n}}
	\end{multline*}

	Die worst-case-Laufzeit von Insertion Sort lässt sich daher nicht einmal durch anwenden der binären Suche auf $\Landau{\log{n}}$ verbessern.

\end{enumerate}

\end{solution}

% --------------------------------------------------------------------------------
